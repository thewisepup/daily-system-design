import { TRPCError } from "@trpc/server";
import { getTodaysNewsletter } from "~/server/newsletter/utils/newsletterUtils";
import { newsletterSequenceRepo } from "~/server/db/repo/newsletterSequenceRepo";
import { topicRepo } from "~/server/db/repo/topicRepo";
import { autoNewsletterService } from "~/server/services/AutoNewsletterService";
import {
  TopicFactory,
  IssueFactory,
  NewsletterSequenceFactory,
} from "tests/factories";

vi.mock("~/server/db/repo/newsletterSequenceRepo", () => ({
  newsletterSequenceRepo: {
    getOrCreate: vi.fn(),
  },
}));

vi.mock("~/server/db/repo/topicRepo", () => ({
  topicRepo: {
    findBySubjectIdAndSequence: vi.fn(),
  },
}));

vi.mock("~/server/services/AutoNewsletterService", () => ({
  autoNewsletterService: {
    ensureApprovedIssue: vi.fn(),
  },
}));

const mockedNewsletterSequenceRepo = vi.mocked(newsletterSequenceRepo);
const mockedTopicRepo = vi.mocked(topicRepo);
const mockedAutoNewsletterService = vi.mocked(autoNewsletterService);

describe("newsletterUtils", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("getTodaysNewsletter", () => {
    const subjectId = 1;

    it("returns issue, sequence, topic with correct flags", async () => {
      const mockSequence = NewsletterSequenceFactory.createNewsletterSequence({
        subjectId,
        currentSequence: 5,
      });
      const mockTopic = TopicFactory.createTopic({
        id: 10,
        subjectId,
        sequenceOrder: 5,
        title: "Load Balancing",
      });
      const mockIssue = IssueFactory.createIssue({
        id: 100,
        topicId: mockTopic.id,
        status: "approved",
        contentJson: { content: "Newsletter content" },
      });

      mockedNewsletterSequenceRepo.getOrCreate.mockResolvedValue(mockSequence);
      mockedTopicRepo.findBySubjectIdAndSequence.mockResolvedValue(mockTopic);
      mockedAutoNewsletterService.ensureApprovedIssue.mockResolvedValue({
        issue: mockIssue,
        wasAutoGenerated: false,
        wasAutoApproved: false,
      });

      const result = await getTodaysNewsletter(subjectId);

      expect(result.issue).toEqual(mockIssue);
      expect(result.sequence).toEqual(mockSequence);
      expect(result.topic).toEqual(mockTopic);
      expect(result.wasAutoGenerated).toBe(false);
      expect(result.wasAutoApproved).toBe(false);

      expect(mockedNewsletterSequenceRepo.getOrCreate).toHaveBeenCalledWith(
        subjectId,
      );
      expect(mockedTopicRepo.findBySubjectIdAndSequence).toHaveBeenCalledWith(
        subjectId,
        mockSequence.currentSequence,
      );
      expect(
        mockedAutoNewsletterService.ensureApprovedIssue,
      ).toHaveBeenCalledWith(mockTopic);
    });

    it("throws NOT_FOUND when newsletter sequence cannot be created", async () => {
      mockedNewsletterSequenceRepo.getOrCreate.mockResolvedValue(null);

      await expect(getTodaysNewsletter(subjectId)).rejects.toMatchObject({
        code: "NOT_FOUND",
        message: "Failed to get or create newsletter sequence",
      });

      expect(mockedTopicRepo.findBySubjectIdAndSequence).not.toHaveBeenCalled();
      expect(
        mockedAutoNewsletterService.ensureApprovedIssue,
      ).not.toHaveBeenCalled();
    });

    it("throws NOT_FOUND when topic is not found for current sequence", async () => {
      const mockSequence = NewsletterSequenceFactory.createNewsletterSequence({
        subjectId,
        currentSequence: 99,
      });

      mockedNewsletterSequenceRepo.getOrCreate.mockResolvedValue(mockSequence);
      mockedTopicRepo.findBySubjectIdAndSequence.mockResolvedValue(undefined);

      await expect(getTodaysNewsletter(subjectId)).rejects.toMatchObject({
        code: "NOT_FOUND",
        message: `No topic found for subjectId ${subjectId} and sequence ${mockSequence.currentSequence}`,
      });

      expect(
        mockedAutoNewsletterService.ensureApprovedIssue,
      ).not.toHaveBeenCalled();
    });

    it("propagates errors from autoNewsletterService", async () => {
      const mockSequence = NewsletterSequenceFactory.createNewsletterSequence({
        subjectId,
        currentSequence: 1,
      });
      const mockTopic = TopicFactory.createTopic({
        id: 1,
        subjectId,
        sequenceOrder: 1,
      });

      mockedNewsletterSequenceRepo.getOrCreate.mockResolvedValue(mockSequence);
      mockedTopicRepo.findBySubjectIdAndSequence.mockResolvedValue(mockTopic);
      mockedAutoNewsletterService.ensureApprovedIssue.mockRejectedValue(
        new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to generate newsletter",
        }),
      );

      await expect(getTodaysNewsletter(subjectId)).rejects.toMatchObject({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to generate newsletter",
      });
    });
  });
});
