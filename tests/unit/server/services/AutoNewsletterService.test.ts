import { TRPCError } from "@trpc/server";
import { autoNewsletterService } from "~/server/services/AutoNewsletterService";
import { newsletterService } from "~/server/services/NewsletterService";
import { issueRepo } from "~/server/db/repo/issueRepo";
import {
  validateStatusTransition,
  canAutoApprove,
} from "~/server/newsletter/issueStatusMachine";
import { TopicFactory, IssueFactory } from "~/test/factories";
import type { IssueStatus } from "~/server/db/schema/issues";

vi.mock("~/server/db/repo/issueRepo", () => ({
  issueRepo: {
    findById: vi.fn(),
    findByTopicId: vi.fn(),
    update: vi.fn(),
    deleteWithCascade: vi.fn(),
  },
}));

vi.mock("~/server/services/NewsletterService", () => ({
  newsletterService: {
    generateNewsletterForTopic: vi.fn(),
  },
}));

vi.mock("~/server/newsletter/issueStatusMachine", () => ({
  validateStatusTransition: vi.fn(),
  canAutoApprove: vi.fn(),
}));

const mockedIssueRepo = vi.mocked(issueRepo);
const mockedNewsletterService = vi.mocked(newsletterService);
const mockedValidateStatusTransition = vi.mocked(validateStatusTransition);
const mockedCanAutoApprove = vi.mocked(canAutoApprove);

/**
 * Helper to assert TRPCError with specific code
 */
async function expectTRPCError(
  promise: Promise<unknown>,
  expectedCode: string,
): Promise<void> {
  await expect(promise).rejects.toThrow(TRPCError);
  try {
    await promise;
  } catch (error) {
    expect(error).toBeInstanceOf(TRPCError);
    expect((error as TRPCError).code).toBe(expectedCode);
  }
}

describe("AutoNewsletterService", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Default: allow all transitions (tests override as needed)
    mockedValidateStatusTransition.mockImplementation(() => undefined);
    mockedCanAutoApprove.mockReturnValue(true);
  });

  describe("ensureApprovedIssue", () => {
    const mockTopic = TopicFactory.createTopic({
      id: 1,
      title: "Load Balancing",
    });

    describe("when no issue exists", () => {
      it("generates a new newsletter and auto-approves it", async () => {
        const generatedIssue = IssueFactory.createIssue({
          id: 10,
          topicId: mockTopic.id,
          status: "draft",
          contentJson: { content: "Generated content" },
        });
        const approvedIssue = IssueFactory.createIssue({
          ...generatedIssue,
          status: "approved",
          approvedAt: new Date(),
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(undefined);
        mockedNewsletterService.generateNewsletterForTopic.mockResolvedValue({
          success: true,
          issueId: generatedIssue.id,
        });
        mockedIssueRepo.findById.mockResolvedValue(generatedIssue);
        mockedIssueRepo.update.mockResolvedValue(approvedIssue);

        const result =
          await autoNewsletterService.ensureApprovedIssue(mockTopic);

        expect(result.issue).toEqual(approvedIssue);
        expect(result.wasAutoGenerated).toBe(true);
        expect(result.wasAutoApproved).toBe(true);
        expect(
          mockedNewsletterService.generateNewsletterForTopic,
        ).toHaveBeenCalledWith(mockTopic.id);
        expect(mockedIssueRepo.findById).toHaveBeenCalledWith(
          generatedIssue.id,
        );
        expect(mockedIssueRepo.update).toHaveBeenCalledWith(
          generatedIssue.id,
          expect.objectContaining({
            status: "approved",
            approvedAt: expect.any(Date),
          }),
        );
      });

      it("throws INTERNAL_SERVER_ERROR when newsletter generation fails", async () => {
        mockedIssueRepo.findByTopicId.mockResolvedValue(undefined);
        mockedNewsletterService.generateNewsletterForTopic.mockResolvedValue({
          success: false,
        });

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "INTERNAL_SERVER_ERROR",
        );
      });

      it("throws INTERNAL_SERVER_ERROR when generation succeeds but issueId is undefined", async () => {
        mockedIssueRepo.findByTopicId.mockResolvedValue(undefined);
        mockedNewsletterService.generateNewsletterForTopic.mockResolvedValue({
          success: true,
          issueId: undefined,
        });

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "INTERNAL_SERVER_ERROR",
        );
      });

      it("throws INTERNAL_SERVER_ERROR when generated issue is not found in database", async () => {
        mockedIssueRepo.findByTopicId.mockResolvedValue(undefined);
        mockedNewsletterService.generateNewsletterForTopic.mockResolvedValue({
          success: true,
          issueId: 999,
        });
        mockedIssueRepo.findById.mockResolvedValue(undefined);

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "INTERNAL_SERVER_ERROR",
        );
      });

      it("throws INTERNAL_SERVER_ERROR when post-generation approval update fails", async () => {
        const generatedIssue = IssueFactory.createIssue({
          id: 10,
          topicId: mockTopic.id,
          status: "draft",
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(undefined);
        mockedNewsletterService.generateNewsletterForTopic.mockResolvedValue({
          success: true,
          issueId: generatedIssue.id,
        });
        mockedIssueRepo.findById.mockResolvedValue(generatedIssue);
        mockedIssueRepo.update.mockResolvedValue(undefined);

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "INTERNAL_SERVER_ERROR",
        );
      });
    });

    describe("when issue exists with approved status", () => {
      it("returns the existing issue without any changes", async () => {
        const approvedIssue = IssueFactory.createIssue({
          id: 5,
          topicId: mockTopic.id,
          status: "approved",
          contentJson: { content: "Pre-approved content" },
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(approvedIssue);

        const result =
          await autoNewsletterService.ensureApprovedIssue(mockTopic);

        expect(result.issue).toEqual(approvedIssue);
        expect(result.wasAutoGenerated).toBe(false);
        expect(result.wasAutoApproved).toBe(false);
        expect(
          mockedNewsletterService.generateNewsletterForTopic,
        ).not.toHaveBeenCalled();
        expect(mockedIssueRepo.update).not.toHaveBeenCalled();
      });
    });

    describe("when issue exists with sent status", () => {
      it("throws CONFLICT error", async () => {
        const sentIssue = IssueFactory.createIssue({
          id: 5,
          topicId: mockTopic.id,
          status: "sent",
          sentAt: new Date(),
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(sentIssue);

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "CONFLICT",
        );
      });
    });

    describe("when issue exists with draft status", () => {
      it("auto-approves the draft if it has content", async () => {
        const draftIssue = IssueFactory.createIssue({
          id: 5,
          topicId: mockTopic.id,
          status: "draft",
          contentJson: { content: "Draft content" },
        });
        const approvedIssue = IssueFactory.createIssue({
          ...draftIssue,
          status: "approved",
          approvedAt: new Date(),
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(draftIssue);
        mockedIssueRepo.update.mockResolvedValue(approvedIssue);

        const result =
          await autoNewsletterService.ensureApprovedIssue(mockTopic);

        expect(result.issue).toEqual(approvedIssue);
        expect(result.wasAutoGenerated).toBe(false);
        expect(result.wasAutoApproved).toBe(true);
        expect(mockedIssueRepo.update).toHaveBeenCalledWith(
          draftIssue.id,
          expect.objectContaining({
            status: "approved",
            approvedAt: expect.any(Date),
          }),
        );
      });

      it("throws PRECONDITION_FAILED when draft has no content", async () => {
        const emptyDraftIssue = IssueFactory.createIssue({
          id: 5,
          topicId: mockTopic.id,
          status: "draft",
          contentJson: null,
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(emptyDraftIssue);

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "PRECONDITION_FAILED",
        );
      });

      it("throws BAD_REQUEST when canAutoApprove returns false", async () => {
        const draftIssue = IssueFactory.createIssue({
          id: 5,
          topicId: mockTopic.id,
          status: "draft",
          contentJson: { content: "Draft content" },
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(draftIssue);
        mockedCanAutoApprove.mockReturnValue(false);

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "BAD_REQUEST",
        );
      });

      it("throws INTERNAL_SERVER_ERROR when auto-approval update fails", async () => {
        const draftIssue = IssueFactory.createIssue({
          id: 5,
          topicId: mockTopic.id,
          status: "draft",
          contentJson: { content: "Draft content" },
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(draftIssue);
        mockedIssueRepo.update.mockResolvedValue(undefined);

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "INTERNAL_SERVER_ERROR",
        );
      });
    });

    describe.each<{ status: IssueStatus; description: string }>([
      { status: "generating", description: "generating" },
      { status: "failed", description: "failed" },
    ])(
      "when issue exists with $description status",
      ({ status, description }) => {
        it(`deletes the ${description} issue and regenerates`, async () => {
          const existingIssue = IssueFactory.createIssue({
            id: 5,
            topicId: mockTopic.id,
            status,
          });
          const newIssue = IssueFactory.createIssue({
            id: 10,
            topicId: mockTopic.id,
            status: "draft",
            contentJson: { content: "Regenerated content" },
          });
          const approvedIssue = IssueFactory.createIssue({
            ...newIssue,
            status: "approved",
            approvedAt: new Date(),
          });

          mockedIssueRepo.findByTopicId.mockResolvedValue(existingIssue);
          mockedIssueRepo.deleteWithCascade.mockResolvedValue({
            success: true,
            deletedIssue: existingIssue,
          });
          mockedNewsletterService.generateNewsletterForTopic.mockResolvedValue({
            success: true,
            issueId: newIssue.id,
          });
          mockedIssueRepo.findById.mockResolvedValue(newIssue);
          mockedIssueRepo.update.mockResolvedValue(approvedIssue);

          const result =
            await autoNewsletterService.ensureApprovedIssue(mockTopic);

          expect(result.issue).toEqual(approvedIssue);
          expect(result.wasAutoGenerated).toBe(true);
          expect(result.wasAutoApproved).toBe(true);
          expect(mockedIssueRepo.deleteWithCascade).toHaveBeenCalledWith(
            existingIssue.id,
          );
          expect(
            mockedNewsletterService.generateNewsletterForTopic,
          ).toHaveBeenCalledWith(mockTopic.id);
        });
      },
    );

    describe("when issue exists with unknown status", () => {
      it("throws INTERNAL_SERVER_ERROR", async () => {
        const unknownStatusIssue = IssueFactory.createIssue({
          id: 5,
          topicId: mockTopic.id,
          // Force an invalid status to test the default case
          status: "unknown_status" as IssueStatus,
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(unknownStatusIssue);

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "INTERNAL_SERVER_ERROR",
        );
      });
    });

    describe("status transition validation", () => {
      it("calls canAutoApprove when auto-approving draft", async () => {
        const draftIssue = IssueFactory.createIssue({
          id: 5,
          topicId: mockTopic.id,
          status: "draft",
          contentJson: { content: "Draft content" },
        });
        const approvedIssue = IssueFactory.createIssue({
          ...draftIssue,
          status: "approved",
          approvedAt: new Date(),
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(draftIssue);
        mockedIssueRepo.update.mockResolvedValue(approvedIssue);

        await autoNewsletterService.ensureApprovedIssue(mockTopic);

        expect(mockedCanAutoApprove).toHaveBeenCalledWith("draft");
      });

      it("calls validateStatusTransition when approving generated issue", async () => {
        const generatedIssue = IssueFactory.createIssue({
          id: 10,
          topicId: mockTopic.id,
          status: "draft",
          contentJson: { content: "Generated content" },
        });
        const approvedIssue = IssueFactory.createIssue({
          ...generatedIssue,
          status: "approved",
          approvedAt: new Date(),
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(undefined);
        mockedNewsletterService.generateNewsletterForTopic.mockResolvedValue({
          success: true,
          issueId: generatedIssue.id,
        });
        mockedIssueRepo.findById.mockResolvedValue(generatedIssue);
        mockedIssueRepo.update.mockResolvedValue(approvedIssue);

        await autoNewsletterService.ensureApprovedIssue(mockTopic);

        expect(mockedValidateStatusTransition).toHaveBeenCalledWith(
          "draft",
          "approved",
        );
      });

      it("throws BAD_REQUEST when canAutoApprove returns false for draft", async () => {
        const draftIssue = IssueFactory.createIssue({
          id: 5,
          topicId: mockTopic.id,
          status: "draft",
          contentJson: { content: "Draft content" },
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(draftIssue);
        mockedCanAutoApprove.mockReturnValue(false);

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "BAD_REQUEST",
        );
      });

      it("throws when validateStatusTransition rejects the transition on generated issue", async () => {
        const generatedIssue = IssueFactory.createIssue({
          id: 10,
          topicId: mockTopic.id,
          status: "draft",
          contentJson: { content: "Generated content" },
        });

        mockedIssueRepo.findByTopicId.mockResolvedValue(undefined);
        mockedNewsletterService.generateNewsletterForTopic.mockResolvedValue({
          success: true,
          issueId: generatedIssue.id,
        });
        mockedIssueRepo.findById.mockResolvedValue(generatedIssue);
        mockedValidateStatusTransition.mockImplementation(() => {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Invalid status transition",
          });
        });

        await expectTRPCError(
          autoNewsletterService.ensureApprovedIssue(mockTopic),
          "BAD_REQUEST",
        );
      });
    });
  });
});
