import { TRPCError } from "@trpc/server";
import { issueRepo } from "~/server/db/repo/issueRepo";
import { newsletterService } from "./NewsletterService";
import type { Issue } from "~/server/db/schema/issues";
import type { Topic } from "~/server/db/schema/topics";
import {
  validateStatusTransition,
  canAutoApprove,
} from "~/server/newsletter/issueStatusMachine";

export interface EnsureApprovedIssueResult {
  issue: Issue;
  wasAutoGenerated: boolean;
  wasAutoApproved: boolean;
}

class AutoNewsletterService {
  /**
   * Ensures an approved issue exists for a given topic.
   * Will auto-generate and/or auto-approve as needed based on current issue status.
   *
   * @param topic - The topic to ensure an approved issue for
   * @returns The approved issue along with flags indicating what actions were taken
   *
   * @throws {TRPCError} CONFLICT - When issue has already been sent
   * @throws {TRPCError} PRECONDITION_FAILED - When draft has no content
   * @throws {Error} When generation or database operations fail
   */
  async ensureApprovedIssue(topic: Topic): Promise<EnsureApprovedIssueResult> {
    if (!topic.id || !topic?.title) {
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "Topic ID and title are required",
      });
    }
    const existingIssue = await issueRepo.findByTopicId(topic.id);

    if (!existingIssue) {
      return this.generateAndApprove(topic);
    }

    return this.handleExistingIssue(existingIssue, topic);
  }

  /**
   * Creates a consistent log prefix for topic-related messages.
   */
  private logContext(topic: Topic): string {
    return `[Topic ${topic.id}] "${topic.title}"`;
  }

  /**
   * Routes an existing issue to the appropriate handler based on its current status.
   * @throws {TRPCError} CONFLICT - When issue has already been sent
   * @throws {TRPCError} INTERNAL_SERVER_ERROR - When status is unrecognized
   */
  private async handleExistingIssue(
    issue: Issue,
    topic: Topic,
  ): Promise<EnsureApprovedIssueResult> {
    switch (issue.status) {
      case "approved":
        console.log(
          `${this.logContext(topic)} - Issue ${issue.id} is already approved`,
        );
        return {
          issue,
          wasAutoGenerated: false,
          wasAutoApproved: false,
        };

      case "sent":
        console.log(
          `${this.logContext(topic)} - Issue ${issue.id} has already been sent`,
        );
        throw new TRPCError({
          code: "CONFLICT",
          message: `Newsletter for topic ${topic.id} has already been sent (Issue ID: ${issue.id})`,
        });

      case "draft":
        return this.autoApproveDraft(issue, topic);

      case "generating":
      case "failed":
        return this.deleteAndRegenerate(issue, topic);

      default: {
        const exhaustiveCheck: never = issue.status;
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: `Unknown issue status: ${exhaustiveCheck as string}`,
        });
      }
    }
  }

  /**
   * Auto-approves a draft issue if it has content.
   * @throws {TRPCError} BAD_REQUEST - If status doesn't support auto-approval
   * @throws {TRPCError} PRECONDITION_FAILED - If draft has no content
   * @throws {TRPCError} INTERNAL_SERVER_ERROR - If database update fails
   */
  private async autoApproveDraft(
    issue: Issue,
    topic: Topic,
  ): Promise<EnsureApprovedIssueResult> {
    validateStatusTransition(issue.status, "approved");

    if (!issue.contentJson) {
      console.error(
        `${this.logContext(topic)} - Draft issue ${issue.id} has no content, cannot auto-approve`,
      );
      throw new TRPCError({
        code: "PRECONDITION_FAILED",
        message: `Draft issue ${issue.id} has no content and cannot be auto-approved`,
      });
    }

    console.log(
      `${this.logContext(topic)} - Auto-approving draft issue ${issue.id}...`,
    );

    const approvedIssue = await issueRepo.update(issue.id, {
      status: "approved",
      approvedAt: new Date(),
    });

    if (!approvedIssue) {
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: `Failed to auto-approve issue ${issue.id}`,
      });
    }

    console.log(
      `${this.logContext(topic)} - Successfully auto-approved issue ${issue.id}`,
    );

    return {
      issue: approvedIssue,
      wasAutoGenerated: false,
      wasAutoApproved: true,
    };
  }

  /**
   * Deletes an existing issue (generating or failed) and regenerates it.
   * Note: There is a small race window between delete and regenerate where
   * another process could create an issue for the same topic.
   * @throws {Error} When deletion or regeneration fails
   */
  private async deleteAndRegenerate(
    issue: Issue,
    topic: Topic,
  ): Promise<EnsureApprovedIssueResult> {
    console.log(
      `${this.logContext(topic)} - Deleting ${issue.status} issue ${issue.id} for regeneration...`,
    );

    await issueRepo.deleteWithCascade(issue.id);
    console.log(`${this.logContext(topic)} - Deleted issue ${issue.id}`);

    return this.generateAndApprove(topic);
  }

  /**
   * Generates a new newsletter and auto-approves it.
   * @throws {TRPCError} INTERNAL_SERVER_ERROR - If generation or approval fails
   * @throws {TRPCError} BAD_REQUEST - If generated issue status doesn't support approval
   */
  private async generateAndApprove(
    topic: Topic,
  ): Promise<EnsureApprovedIssueResult> {
    console.log(
      `${this.logContext(topic)} - No approved issue found, auto-generating...`,
    );

    const result = await newsletterService.generateNewsletterForTopic(topic.id);

    if (!result.success || !result.issueId) {
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: `Failed to generate newsletter for topic ${topic.id}`,
      });
    }

    const generatedIssue = await issueRepo.findById(result.issueId);
    if (!generatedIssue) {
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: `Generated issue ${result.issueId} not found in database`,
      });
    }

    validateStatusTransition(generatedIssue.status, "approved");

    console.log(
      `${this.logContext(topic)} - Newsletter generated (Issue ID: ${result.issueId}), auto-approving...`,
    );

    const approvedIssue = await issueRepo.update(result.issueId, {
      status: "approved",
      approvedAt: new Date(),
    });

    if (!approvedIssue) {
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: `Failed to auto-approve generated issue ${result.issueId}`,
      });
    }

    console.log(
      `${this.logContext(topic)} - Successfully auto-generated and approved issue ${result.issueId}`,
    );

    return {
      issue: approvedIssue,
      wasAutoGenerated: true,
      wasAutoApproved: true,
    };
  }
}

export const autoNewsletterService = new AutoNewsletterService();
