import { TRPCError } from "@trpc/server";
import { newsletterSequenceRepo } from "~/server/db/repo/newsletterSequenceRepo";
import { deliveryRepo } from "~/server/db/repo/deliveryRepo";
import { emailService } from "~/server/email/emailService";
import {
  convertContentJsonToHtml,
  convertContentJsonToText,
} from "~/server/email/templates/newsletterTemplate";
import type { NewsletterResponse } from "~/server/llm/schemas/newsletter";
import type {
  EmailSendRequest,
  SendNewsletterRequest,
  MessageTag,
} from "~/server/email/types";
import {
  generateOneClickUnsubscribeUrl,
  generateUnsubscribePageUrl,
} from "~/lib/unsubscribe";
import { env } from "~/env";

import { topicRepo } from "~/server/db/repo/topicRepo";
import type { User } from "~/server/db/schema/users";
import type { NewsletterSequence } from "~/server/db/schema/newsletterSequence";
import type { Issue } from "~/server/db/schema/issues";
import type { Topic } from "~/server/db/schema/topics";
import { DB_FETCH_SIZE } from "~/server/email/constants/bulkEmailConstants";
import { MESSAGE_TAG_NAMES } from "~/server/email/constants/messageTagNames";
import { userService } from "~/server/services/UserService";
import { generateFeedbackPageUrl } from "~/lib/jwt/FeedbackTokenService";
import { autoNewsletterService } from "~/server/services/AutoNewsletterService";

const NEWSLETTERS_ARCHIVE_URL = `${env.NEXT_PUBLIC_APP_URL}/newsletter`;

export interface GetTodaysNewsletterResult {
  issue: Issue;
  sequence: NewsletterSequence;
  topic: Topic;
  wasAutoGenerated: boolean;
  wasAutoApproved: boolean;
}

/**
 * Get today's newsletter by current sequence for a subject.
 * If no approved newsletter exists, it will auto-generate and/or auto-approve as needed.
 */
export async function getTodaysNewsletter(
  subjectId: number,
): Promise<GetTodaysNewsletterResult> {
  console.log(
    `[${new Date().toISOString()}] [INFO] Getting today's newsletter`,
    {
      subjectId,
    },
  );

  const sequence = await newsletterSequenceRepo.getOrCreate(subjectId);
  if (!sequence) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: "Failed to get or create newsletter sequence",
    });
  }

  console.log(
    `[${new Date().toISOString()}] [INFO] Current sequence retrieved`,
    {
      subjectId,
      currentSequence: sequence.currentSequence,
    },
  );
  const topic = await topicRepo.findBySubjectIdAndSequence(
    subjectId,
    sequence.currentSequence,
  );

  if (!topic) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: `No topic found for subjectId ${subjectId} and sequence ${sequence.currentSequence}`,
    });
  }

  const { issue, wasAutoGenerated, wasAutoApproved } =
    await autoNewsletterService.ensureApprovedIssue(topic);

  return { issue, sequence, topic, wasAutoGenerated, wasAutoApproved };
}

/**
 * Generate email headers including unsubscribe headers
 */
export function generateEmailHeaders(userId: string) {
  const oneClickUnsubscribeUrl = generateOneClickUnsubscribeUrl(userId);
  return {
    "List-Unsubscribe": `<${oneClickUnsubscribeUrl}>`,
    "List-Unsubscribe-Post": "List-Unsubscribe=One-Click",
  };
}

/**
 * Generate HTML content with template substitutions
 */
function generateHtmlContentWithSubstitutions(
  issue: Issue,
  substitutions: Record<string, string>,
): string {
  if (issue.contentJson) {
    let htmlTemplate = convertContentJsonToHtml(
      issue.contentJson as NewsletterResponse,
      issue.title,
    );
    Object.entries(substitutions).forEach(([key, value]) => {
      htmlTemplate = htmlTemplate.replace(new RegExp(`{{${key}}}`, "g"), value);
    });
    return htmlTemplate;
  } else {
    throw new Error(
      `Issue ${issue.id} is missing both rawHtml and contentJson - cannot generate email content`,
    );
  }
}

/**
 * Generate plain text content with template substitutions
 */
function generateTextContentWithSubstitutions(
  issue: Issue,
  substitutions: Record<string, string>,
): string {
  //TODO: We should store rawText in issues table and just do substitutions
  if (issue.contentJson) {
    let textTemplate = convertContentJsonToText(
      issue.contentJson as NewsletterResponse,
      issue.title,
    );
    Object.entries(substitutions).forEach(([key, value]) => {
      textTemplate = textTemplate.replace(new RegExp(`{{${key}}}`, "g"), value);
    });
    return textTemplate;
  } else {
    throw new Error(
      `Issue ${issue.id} is missing contentJson - cannot generate email text content`,
    );
  }
}

/**
 * Generate EmailSendRequest object for a single user
 */
export function generateEmailSendRequest(
  user: User,
  issue: Issue,
  subjectId: number,
  sequenceNumber: number,
): EmailSendRequest {
  const unsubscribePageUrl = generateUnsubscribePageUrl(user.id);
  const headers = generateEmailHeaders(user.id);
  const tags = generateStandardTags(user.id, subjectId, sequenceNumber);
  const feedbackUrl = generateFeedbackPageUrl(user.id, issue.id);
  const substitutions = {
    UNSUBSCRIBE_URL: unsubscribePageUrl,
    FEEDBACK_URL: feedbackUrl,
    NEWSLETTERS_URL: NEWSLETTERS_ARCHIVE_URL,
  };

  return {
    to: user.email,
    from: env.AWS_SES_FROM_EMAIL,
    subject: issue.title,
    html: generateHtmlContentWithSubstitutions(issue, substitutions),
    text: generateTextContentWithSubstitutions(issue, substitutions),
    headers,
    userId: user.id,
    deliveryConfiguration: env.AWS_SES_CONFIGURATION_SET,
    tags,
  };
}

/**
 * Generate EmailSendRequest objects for a batch of users
 */
export async function generateEmailSendRequests(
  users: User[],
  issue: Issue,
  subjectId: number,
  sequenceNumber: number,
): Promise<EmailSendRequest[]> {
  return users.map((user) =>
    generateEmailSendRequest(user, issue, subjectId, sequenceNumber),
  );
}

/**
 * Process a single batch of users for newsletter delivery
 */
export async function processBatch(
  users: User[],
  issue: Issue,
  subjectId: number,
  sequenceNumber: number,
) {
  if (users.length === 0) {
    return { totalSent: 0, totalFailed: 0, failedUserIds: [] };
  }

  const userIds = users.map((u) => u.id);
  const batchStartTime = Date.now();

  try {
    console.log(`[${new Date().toISOString()}] [INFO] Processing batch`, {
      batchSize: users.length,
      issueId: issue.id,
      sequenceNumber,
    });
    const emailRequests = await generateEmailSendRequests(
      users,
      issue,
      subjectId,
      sequenceNumber,
    );

    const bulkRequest: SendNewsletterRequest = {
      entries: emailRequests,
      issue_id: issue.id,
    };
    const bulkResults = await emailService.sendNewsletterIssue(bulkRequest);

    const batchDuration = Date.now() - batchStartTime;
    console.log(
      `[${new Date().toISOString()}] [INFO] Batch processing completed`,
      {
        batchSize: users.length,
        sent: bulkResults.totalSent,
        failed: bulkResults.totalFailed,
        duration: `${batchDuration}ms`,
      },
    );

    return bulkResults;
  } catch (error) {
    const batchDuration = Date.now() - batchStartTime;
    console.error(
      `[${new Date().toISOString()}] [ERROR] Batch processing failed`,
      {
        batchSize: users.length,
        issueId: issue.id,
        duration: `${batchDuration}ms`,
        error: error instanceof Error ? error.message : String(error),
      },
    );

    //TODO: figure out if updating deliver repo here is a good idea for error handling
    const failedUpdates = userIds.map((userId) => ({
      userId,
      status: "failed" as const,
      errorMessage: error instanceof Error ? error.message : "Unknown error",
    }));

    deliveryRepo
      .bulkUpdateStatuses(issue.id, failedUpdates)
      .catch((updateError) => {
        console.error(
          `[${new Date().toISOString()}] [ERROR] Failed to update delivery statuses`,
          {
            issueId: issue.id,
            updateCount: failedUpdates.length,
            error:
              updateError instanceof Error
                ? updateError.message
                : String(updateError),
          },
        );
      });

    return {
      totalSent: 0,
      totalFailed: users.length,
      failedUserIds: userIds,
    };
  }
}

export function canSendIssue(issue: Issue | undefined) {
  if (!issue) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: "Newsletter not found for this topic",
    });
  }

  if (issue.status !== "approved") {
    throw new TRPCError({
      code: "PRECONDITION_FAILED",
      message: `Cannot send newsletter with status: ${issue.status}. Newsletter must be approved first.`,
    });
  }

  // TODO: Update validation to check contentJson instead of content
  if (!issue.contentJson) {
    throw new TRPCError({
      code: "PRECONDITION_FAILED",
      message: "Newsletter content is empty",
    });
  }
}

export interface BatchAggregatedResults {
  totalSent: number;
  totalFailed: number;
  failedUserIds: string[];
  processedUsers: number;
}

/**
 * Helper function to aggregate batch results
 */
export function aggregateBatchResults(
  currentResults: BatchAggregatedResults,
  batchResults: {
    totalSent: number;
    totalFailed: number;
    failedUserIds: string[];
  },
): BatchAggregatedResults {
  return {
    totalSent: currentResults.totalSent + batchResults.totalSent,
    totalFailed: currentResults.totalFailed + batchResults.totalFailed,
    failedUserIds: [
      ...currentResults.failedUserIds,
      ...batchResults.failedUserIds,
    ],
    processedUsers:
      currentResults.processedUsers +
      batchResults.totalSent +
      batchResults.totalFailed,
  };
}

/**
 * Process all users in batches using pagination
 */
export async function processAllUsersInBatches(
  issue: Issue,
  sequenceNumber: number,
  subjectId: number,
): Promise<BatchAggregatedResults> {
  let results: BatchAggregatedResults = {
    totalSent: 0,
    totalFailed: 0,
    failedUserIds: [],
    processedUsers: 0,
  };

  let page = 1;

  while (true) {
    const start = (page - 1) * DB_FETCH_SIZE + 1;
    const end = page * DB_FETCH_SIZE;
    console.log(
      `[${new Date().toISOString()}] [INFO] Fetching user batch ${page}`,
      {
        batchRange: `${start}-${end}`,
        pageSize: DB_FETCH_SIZE,
      },
    );

    const users = await userService.getUsersWithActiveSubscription(
      page,
      DB_FETCH_SIZE,
    );

    // No more users to process
    if (users.length === 0) {
      break;
    }
    const batchResults = await processBatch(
      users,
      issue,
      subjectId,
      sequenceNumber,
    );
    results = aggregateBatchResults(results, batchResults);
    page++;

    // End if current batch is less than fetch size
    if (users.length < DB_FETCH_SIZE) {
      break;
    }
  }

  return results;
}

function generateStandardTags(
  userId: string,
  subjectId: number,
  sequenceNumber: number,
): MessageTag[] {
  const tags: MessageTag[] = [
    { name: MESSAGE_TAG_NAMES.USER_ID, value: userId },
    { name: MESSAGE_TAG_NAMES.SUBJECT_ID, value: subjectId.toString() },
    { name: MESSAGE_TAG_NAMES.ISSUE_NUMBER, value: sequenceNumber.toString() },
  ];
  return tags;
}
